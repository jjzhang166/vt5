//#include <stdlib.h>
#include "Gost.h"
#pragma intrinsic(_rotr,_rotl)
#if _MSC_VER < 1400 
__inline static unsigned char _bittest(unsigned int* pdw, int n){
	__asm {
		xor eax,eax
		mov ebx, n
		mov ecx,[pdw]
		bt [ecx], ebx
		adc eax,eax
	}
}
#else
#pragma intrinsic(_bittest)
#endif

//;>Параметры  при  вызове:
//;   EAX - младшая часть преобразуемого блока (N1);
//;   EDX - старшая часть преобразуемого блока (N2);
//;   ESI - адрес первого элемента ключа;
//;   EBX - адрес таблицы замен;
//;   ECX - число основных шагов
//;>Результаты на выходе:
//;   EDX=N1, EAX=N2 для циклов 32-З,32-Р;
//;   EAX=N1, EDX=N2 для цикла  16-З;
//;>Используемые регистры:  все кроме EDI
//;>Замечания:
//;  В конце выполнения содержимое регистров следующее:
//;  EBX-(указатель таблицы замен) - то же, что в начале
//;  ESI-(указатель ключа) - указывает на первый байт за
//;      ключом - это на N*4 больше первоначального зна-
//;      чения SI для цикла с числом повторений N.
//;      (для циклов шифрования N=32 => 4*N=128, для
//;      цикла выработки имитовставки N=16 => 4*N=64)
//;      больше первоначального значения для цикла выра-
//;      ботки имитоприставки.
//;  ECX=0
//;  Содержимое сегментных регистров не изменяется.
__inline void gost(UINT8* xcht,CrBlock* pBlock, CrItem *key, DWORD_PTR keylen)
{
// 1. Начало  цикла  и  сохранение  старого  N1
// iloop:  mov     EBP,EAX
// 2. Добавление  к  S  ключа  по  модулю  2^32
//        add     EAX,[RSI] ; добавить    ключ
//        add     ESI,4   ; следующий  эл. ключа
// 3. Поблочная замена в S с вращением на 8 бит влево
//REPT    3
//        xlat            ; перекодировка  байта
//        ror     EAX,8   ; AL <- следующий байт
//        add     EBX,100h; следующий узел замен
//ENDM
//        xlat            ; перекодировка  байта
//        sub     EBX,300h; BX -> 1-й узел замен
// 4. Доворот  S  на  3  бита  влево
//        rol     EAX,3
// 5. Вычисление  новых  значений  N1,N2
//	xor     EAX,EDX
//	mov     EDX,EBP
// Завершение  внутреннего  цикла
//	loop    iloop
//	ret
	
	union{
		UINT32 N;
		struct{
			UINT8 B0,B1,B2,B3;
		};
	} N1;

	N1.N=pBlock->low;

	while(keylen--){
		
		N1.N += *key++;
		
		N1.B0=xcht[N1.B0];
		N1.B1=xcht[N1.B1+0x100];
		N1.B2=xcht[N1.B2+0x200];
		N1.B3=xcht[N1.B3+0x300];

		N1.N=_rotl(N1.N,11);
		N1.N ^= pBlock->high;

		pBlock->high=pBlock->low;
		pBlock->low=N1.N;
	}
}

// Расширение таблицы замен
void __cdecl ExpCht(CrItem * source,		//   область исходной ТЗ
					CrItem * target)		//   область расширенной ТЗ
{
//;------------------------------------------------------
//; Построение расширенной таблицы замен (1024 байт) из
//; таблицы замен (128 байт) алгоритма  ГОСТ 28147-89.
//;------------------------------------------------------
//; Параметры при вызове передаются в стэке :
//; Смещение Размер   П  А  Р  А  М  Е  Т  Р
//;    4       4     NEAR32-адрес исходной таблицы замен
//;    8       4     NEAR32-адрес области для расширения
//;------------------------------------------------------
//; Значения параметров при выходе не изменяются
//;------------------------------------------------------
//; Сохранение регистров по соглашениям о вызовах функций
//;
//; Загрузка параметров в регистры и прочие настройки
//        mov     ESI,arg_shift[ESP]  ;ESI-->источник
//        mov     EDI,arg_shift+4[ESP];EDI-->приемник
//        cld
	UINT8  *pSource, *pTarget;
	unsigned int ECX;
	pSource=(UINT8*)source;
	pTarget=(UINT8*)target;
//; Цикл  по  блокам  расширенной  таблицы  замен
//        mov     ECX,4   ; ECX <- число блоков ТЗ
	for(ECX=4; ECX--; pSource += 0x20) {
//blocks:	lea     EBX,[10h+ESI] ; EBX<-адрес  начала
		int line;
		unsigned char* EBX;
		EBX=(unsigned char*)pSource+0x10;

		//; Цикл  по  линиям  блока
		//        push    ECX     ; сохранить  счетчик блоков
		//        mov     CL,16   ; загрузить  счетчик  линий
		//lines:  push    ESI     ; сохр. указ. текущ.  блока
		for(line=16;line--;){
//        mov     AH,[EBX]; AH <- старший    полубайт
//        shl     AH,4    ; сдвиг полубайта
			int i;
			UINT8 byte;
			byte=*EBX++;
			byte<<=4;
//; Цикл  по  байтам  линии
//        push    ECX     ; сохранить   счетчик линий
//        mov     CL,16   ; загрузить счетчик  байтов
			for(i=0; i<16; ++i){
//bytes:  lodsb           ; загрузить очередной  байт
//	or      AL,AH   ; добавить старший полубайт
//        stosb           ; ...  и записать результат
				*pTarget++ = *(pSource+i) ^ byte;
//        loop    bytes   ; цикл   по  байтам   линни
			}
//; Проверка  цикла  по  линиям
//        pop     ECX     ; восстанов. счетчик  линий
//        pop     ESI     ; восст. указат. тек. блока
//        inc     EBX     ; продвинуть указатель байт
//        loop    lines   ; цикл  по строкам  таблицы
		}
//; Проверка  цикла  по  блокам
//        pop     ECX     ; восстанов. счетчик блоков
//        add     ESI,20h ; продвинуть  указат. блока
//        loop    blocks  ; цикл по блокам
	}
	//	ret
}

// Любое расширение ключа
void __cdecl ExpandKey (CrItem * source,	//   область исходного ключа
						CrItem * target,	//   область расширен. ключа
						DWORD   KeyLength,	//   размер ключа
						DWORD   KeyRepeat,	//   число повторений ключа
						DWORD   RepeatMask,
						...)				//   маска повторений ключа
{
//;------------------------------------------------------
//; Построение расширенного ключа шифрования из однократ-
//; ного ключа для шифра типа ГОСТ 28147-89.
//; ** Схема расширения задается маской расширения.
//; ** Маска расширения может иметь размер 1..32767 бит.
//;------------------------------------------------------
//; Параметры при вызове передаются в стэке :
//;   Имя        Тип    Смысл
//;   Key        DWORD  NEAR32-адрес исходного ключа
//;   Target     DWORD  NEAR32-адрес области назначения
//;   KeyLength  DWORD  размер ключа в 4-байтовых блоках
//;   KeyRepeat  DWORD  число повторений ключа
//;   RepeatMask DWORD:? массив битов направлений
//; Возвращаемое значение:  число выполенных копий ключа
//; - равно параметру KeyRepeat, если KeyRepeat >= 0;
//; - равно 0, если KeyRepeat < 0;
//;------------------------------------------------------
//ExpandKey proc  near\
//	 	USES		ESI EDI EBX,\
//		Key:		DWORD,\
//		Target:         DWORD,\
//		KeyLength:      DWORD,\
//		KeyRepeat:      DWORD,\
//		RepeatMask:	DWORD
//; Настройка регистров
//		pushfd			; Сохраняем флаг 'D'
//		mov     ESI,Key		; ESI=адрес ключа
//		mov     EDI,Target	; EDI=адрес назначения
//    mov     EAX,KeyLength	; EAX <- кол.эл-тов кл.
//    lea     EBX,[ESI+4*EAX-4]; EBX <- адрес конца ключа
//		xor     EAX,EAX		; EAX=0
//		cld
	int*pKey, *pTarget;
	//;
	//; Проверка условия завершения цикла
	//;
	//begin:	cmp	EAX,KeyRepeat	; нужное число сделано ?
	//		jge 	short exit	; если да, выход
	DWORD iKeyRep;
	pTarget=target;
	for(iKeyRep=0; iKeyRep<KeyRepeat; ++iKeyRep)
	{
		//		mov	ECX,KeyLength	; ECX=длина ключа
		//		bt 	RepeatMask,EAX	; CF=очередной бит маски
		if(!_bittest(&RepeatMask,iKeyRep)){
			// Повторение элементов ключа в прямом порядке
			//		jc	short Reverse	; CF=1 -> реверс
			//		mov	ESI,DWord PTR Key; ESI=смещение ключа
			//    rep movsd			; копируем ключ
			//		jmp short Incr    	; на счет повтор. ключа
			for(pKey=source; pKey<source+KeyLength; )
				*pTarget++ = *pKey++;

		}else{
			//; Повторение элементов ключа в обратном порядке
			//;
			//Reverse:mov	ESI,EBX		; ESI=адрес конца ключа
			//rev:	movsd			;        слова ключа
			//    sub  	ESI,8		; к предш. элементу
			//    loop	rev		; организация цикла
			for(pKey=source+KeyLength; pKey>source; )
				*pTarget++ = *--pKey;
		}
		//Incr:	inc     EAX		; счетчик повторов ключа
		//		jmp	begin
	}
	//	ret
}

//// Гаммирование данных
//void __cdecl gamma (CrItem * key,			//   адрес ключа
//					CrItem * synchro,		//   адрес синхропосылки
//					void *	 xcht,			//   адрес таблицы замен
//					void *   data,			//   адрес гаммируемых данных
//					DWORD_PTR    blocks,		//   число шифруемых блоков
//					DWORD_PTR    keylen)       //   длина ключа в элементах
//{
//}
//
//// Выработка гаммы
//void __cdecl gamme (CrItem * key,			//   адрес ключа
//					CrItem * synchro,		//   адрес синхропосылки
//					void *   xcht,			//   адрес таблицы замен
//					void *   data,			//   адрес гаммируемых данных
//					DWORD_PTR    blocks,		//   число шифруемых блоков
//					DWORD_PTR    keylen)		//   длина ключа в элементах
//{
//}

// Зашифрование-гаммир. с ОС
void __cdecl gammaLE(CrItem * key,			//   адрес ключа
					 CrItem * synchro,		//   адрес синхропосылки
					 void *   xcht,			//   адрес таблицы замен
					 void *   data,			//   адрес гаммируемых данных
					 DWORD_PTR    blocks,		//   число шифруемых блоков
					 DWORD    keylen)		//   длина ключа в элементах
{
//;------------------------------------------------------
//; Значения параметров при выходе:
//; - адрес области назначения указывыет  на первый байт
//;   после последнего обработанного блока;
//; - адреса ключа, таблицы замен и синхропосылки не из-
//;   менились;
//; - синхропосылка  содержит  значение,  с которым надо
//;   вызвать функцию для продолжения шифрования;
//; - счетчик шифруемых блоков равен 0;
//;------------------------------------------------------
//key=    arg_shift +  0
//syn=    arg_shift +  4
//chg=    arg_shift +  8
//tar=    arg_shift + 12
//len=    arg_shift + 16
//keylen= arg_shift + 20
//
//; Загрузка синхропосылки
//        mov     ESI,syn[ESP]    ; ESI <- адрес СП (S2,S1)
//        mov     EAX,[ESI]       ; EAX <- S1
//        mov     EDX,[ESI+4]     ; EDX <- S2
//; Начальная загрузка указателей
//        mov     EBX,chg[ESP]    ; EBX <- адрес ТЗ
//        mov     EDI,tar[ESP]    ; EDI <- сегмент назн.
//; Вызов простой замены;
//circle:
//        mov     ECX,keylen[ESP] ; ECX <- число основн. шагов
//        mov     ESI,key[ESP]    ; ESI <- адрес ключа
//        call    _gost32         ; <шаг простой замены>
//; Использование  сгенерированного  блока  гаммы
//; будет альтернатива
//;       xchg    EAX,EDX         ; обмен значениями S1<-->S2
//;       xor     EAX,[EDI]       ; Шифруем
//;       xor     EDX,[EDI+4]     ;    блок данных
//;       mov     [EDI],EAX       ; и записываем его
//;       mov     [EDI+4],EDX     ;   на нужное место
//; альтернатива последним 5 строкам:короче,но медленнее
//        xor     [EDI],EDX       ;   блок данных
//        xor     [EDI+4],EAX     ; Гаммируем 8-байтовый
//        mov     EAX,[EDI]       ; Загружаем блок для
//        mov     EDX,[EDI+4]     ;   следующего шага
//; альтернатива закончена
//; Организация цикла
//        add     EDI,8           ; коррекция адреса назн.
//        dec     dptr len[ESP]   ; коррекция счетчика  б.
//        jnz     circle          ; циклимся
//; Сохранение синхропосылки для следующего вызова
//; (это нужно для обработки массива данных частями, в
//; противном случае можно удалить эту секцию)
//        mov     ESI,syn[ESP]     ; DS:SI -> синхропосылка
//        mov     [ESI],EAX        ; заносим новые значения
//        mov     [ESI+4],EDX      ;   S1,S2 на их место !!!
//        ret
	CrBlock* pBlock;
	for(pBlock=(CrBlock*)data; pBlock<((CrBlock*)data)+blocks; ++pBlock){
		gost((UINT8*)xcht,(CrBlock*)synchro,key,keylen);
		pBlock->low ^= ((CrBlock*)synchro)->high;
		pBlock->high ^= ((CrBlock*)synchro)->low;
		*(CrBlock*)synchro = *pBlock;
	}
}

// Расшифрование-гаммир. с ОС
void __cdecl gammaLD(CrItem * key,			//   адрес ключа
					 CrItem * synchro,		//   адрес синхропосылки
					 void *   xcht,			//   адрес таблицы замен
					 void *   data,			//   адрес гаммируемых данных
					 DWORD_PTR    blocks,		//   число шифруемых блоков
					 DWORD    keylen)		//   длина ключа в элементах
{
//;------------------------------------------------------
//; Расшифрование массива данных в режиме гаммирования с
//; обратной связью согласно алгоритму ГОСТ 28147-89.
//;------------------------------------------------------
//; Значения параметров при выходе:
//; - адрес области назначения указывыет  на первый байт
//;   после последнего обработанного блока;
//; - адреса ключа, таблицы замен и синхропосылки не из-
//;   менились;
//; - синхропосылка  содержит  значение,  с которым надо
//;   вызвать функцию для продолжения шифрования;
//; - счетчик шифруемых блоков равен 0;
//;
//key=    arg_shift +  0
//syn=    arg_shift +  4
//chg=    arg_shift +  8
//tar=    arg_shift + 12
//len=    arg_shift + 16
//keylen= arg_shift + 20
//
//; Загрузка синхропосылки
//        mov     ESI,syn[ESP]    ; ESI <- адрес СП (S2,S1)
//        mov     EAX,[ESI]       ; EAX <- S1
//        mov     EDX,[ESI+4]     ; EDX <- S2
//; Начальная загрузка указателей
//        mov     EBX,chg[ESP]    ; EBX <- адрес ТЗ
//        mov     EDI,tar[ESP]    ; EDI <- адрес назначения
//; Вызов простой замены;
//circle:
//        mov     ECX,keylen[ESP] ; ECX <- число основн. шагов
//        mov     ESI,key[ESP]    ; ESI <- адрес ключа
//        call    _gost32         ; <шаг простой замены>
//; Использование  сгенерированного  блока  гаммы
//        xchg    EAX,EDX         ; обмен значениями S1<-->S2
//        xor     EAX,[EDI]       ; гаммирование 8-байтового
//        xor     EDX,[EDI+4]     ;    блока данных
//        xchg    [EDI],EAX       ; обмен его с
//        xchg    [EDI+4],EDX     ;    блоком шифротекста
//; Организация цикла
//        add     EDI,8           ; коррекция адреса назн.
//        dec     dptr len[ESP]   ; коррекция счетчика  б.
//        jnz     circle          ; циклимся
//; Сохранение синхропосылки для следующего вызова
//; (это нужно для обработки массива данных частями, в
//; противном случае можно удалить эту секцию)
//        mov     ESI,syn[ESP]    ; ESI -> синхропосылка
//        mov     [ESI],EAX       ; заносим новые значения
//        mov     [ESI+4],EDX     ;   S1,S2 на их место !!!
//	ret
	CrBlock* pBlock;
	for(pBlock=(CrBlock*)data; pBlock<((CrBlock*)data)+blocks; ++pBlock){
		UINT32 temp;
		UINT64 ui64;

		gost((UINT8*)xcht,(CrBlock*)synchro,key,keylen);
		temp=synchro[0];
		synchro[0]=synchro[1];
		synchro[1]=temp;

		ui64=*(UINT64*)pBlock;
		*(UINT64*)pBlock ^= *(UINT64*)synchro;
		*(UINT64*)synchro = ui64;
	}
}

// Шифрование простой заменой
void __cdecl simple(CrItem * key,		//   адрес ключа
					void*   data,					//   адрес шифруемых данных
					void*   xcht,						//   адрес таблицы замен
					DWORD_PTR    blocks,			//   число шифруемых блоков
					DWORD    keylen)			//   длина ключа в элементах
{
//key=    arg_shift +  0
//tar=    arg_shift +  8
//chg=    arg_shift + 16
//len=    arg_shift + 24
//keylen= arg_shift + 32
//
//; Начальная загрузка указателей
//        mov     EBX,chg[ESP]    ; EBX <- адрес ТЗ
//        mov     EDI,tar[ESP]    ; EDI <- адрес назн.
//; Загрузка блока данных
//circle: mov     EAX,[RDI]       ; EAX <- S1
//        mov     EDX,[RDI+4]     ; EDX <- S2
//; Вызов простой замены;
//        mov     ECX,keylen[ESP] ; ECX <- число основн. шагов
//        mov     ESI,key[ESP]    ; ESI <- адрес ключа
//        call    _gost32         ; <шаг простой замены>
//; Запись  результата  на  место
//        mov     [RDI+4],EAX     ; Заносим результат
//        mov     [RDI],EDX       ;   на его место
//; Организация цикла
//        add     EDI,8           ; коррекция адреса назн.
//        dec     dptr len[ESP]   ; коррекция счетчика  б.
//        jnz     circle          ; циклимся
	CrBlock* pBlock;
	for(pBlock=(CrBlock*)data; pBlock<((CrBlock*)data)+blocks; ++pBlock){
		gost((UINT8*)xcht,pBlock,key,keylen);
	}
}

// Вычисление имитоприставки
CrItem __cdecl imito(CrItem * key,			//   адрес ключа
					 CrItem * combine,		//   адрес начальной комбинации
					 void *   xcht,			//   адрес таблицы замен
					 void *   data,			//   адрес гаммируемых данных
					 DWORD_PTR    blocks,		//   число блоков
					 DWORD    keylen)		//   длина ключа в элементах
{
//;------------------------------------------------------
//; Выработка имивставки для массива данных согласно
//; криптоалгоритму ГОСТ 28147-89.
//;------------------------------------------------------
//; Значения параметров при выходе:
//; - адрес области назначения указывыет  на первый байт
//;   после последнего обработанного блока;
//; - адреса ключа, таблицы замен и контрольной комбина-
//;   ции не изменились;
//; - область контрольной комбинации содержит значение,
//;   с которым надо вызвать функцию для продолжения;
//; - счетчик блоков равен 0;
//; - регистр  EAX  содержит младшее двойное слово  кон-
//;   трольной комбинации,  используемое обычно как ими-
//;   товставка,что соответствует возврату значения типа
//;   Item,    определенного    в    файле   gost.h  как
//;   unsigned long.
//;------------------------------------------------------
//key=    arg_shift +  0
//syn=    arg_shift +  4
//chg=    arg_shift +  8
//tar=    arg_shift + 12
//len=    arg_shift + 16
//keylen= arg_shift + 20
//
//; Загрузка начального значения контрольной комбинации
//        mov     ESI,syn[ESP]    ; ESI <- адрес ИК (S2,S1)
//        mov     EAX,[ESI]       ; EAX <- S1
//        mov     EDX,[ESI+4]     ; EDX <- S2
//; Начальная загрузка указателей
//        mov     EBX,chg[ESP]    ; EBX <- адрес ТЗ
//        mov     EDI,tar[ESP]    ; EDI <- адрес данных
//; Добавляем блок данных
//circle: xor     EAX,[EDI]       ; Гаммируем
//        xor     EDX,[EDI+4]     ;    8-байтный блок
//; Вызов простой замены;
//        mov     ECX,keylen[ESP] ; ECX <- число основн. шагов
//        mov     ESI,key[ESP]    ; ESI <- адрес ключа
//        call    _gost32         ; <шаг простой замены>
//; Организация цикла
//        add     EDI,8           ;коррекция адреса назн.
//        dec     dptr len[ESP]   ;коррекция счетчика б.
//        jnz     circle          ; циклимся
//; Сохранение контрольной комбинации для след. вызова
//; (это нужно для обработки массива данных частями, в
//; противном случае можно удалить эту секцию)
//        mov     ESI,syn[ESP]    ; ESI -> синхропосылка
//        mov     [ESI],EAX       ; заносим новые значения
//        mov     [ESI+4],EDX     ;   S1,S2 на их место !!!
//; Восстановление регистров из стэка
//        pop     EBX
//	pop     EDI
//	pop     ESI
//	pop     EBP
//        ret
//_imito  endp
//	end

	CrBlock* pBlock;
	for(pBlock=(CrBlock*)data; pBlock<((CrBlock*)data)+blocks; ++pBlock){
		*(UINT64*)combine ^= *(UINT64*)pBlock;
		gost((UINT8*)xcht,(CrBlock*)combine,key,keylen);
	}
	return *combine;
}
